
从地址栏输入url,回车到页面展示中间，发生了什么事情？
1. DNS解析     	==》DNS解析过程（参考：http://www.ruanyifeng.com/blog/2016/06/dns.html）ok
2. 三次握手     ==》之前有整理（手稿）
3. http请求     ==》http报文格式， 头部内容及作用，https（ok）， http1.1/2.0版本，get / post请求的区别
4. 四次挥手     ==》之前有整理（手稿）
5. 页面渲染     ==》浏览器的渲染机制 （参考：https://cloud.tencent.com/developer/article/1004695）
			==》重排，重绘
			==》js 时间线



浏览器发生网络请求是使用：ajax  （ajax的兼容写法）
浏览器有：同源策略

同源策略就限制了ajax, 所以就出现一个问题：怎么实现跨域？

jsonp封装 ok

Ajax 解决浏览器缓存

http的无状态 ==》 cookie,session  ==》 cookie ok
http的无连接 ==》keep-alive ==> 怎么回事？


前端性能优化：
	缓存 (参考：https://juejin.im/post/5dafae866fb9a04e0762e846#heading-10)
	DNS解析
	重排，重绘


0. 查缓存     ==》 浏览器的缓存机制 （参考：https://juejin.im/post/58eacff90ce4630058668257） ok

浏览器的缓存机制（HTTP的缓存策略）
浏览器的渲染机制
V8引擎

缓存 和 DNS解析哪一个先进行？


cookie的知识，在整理一遍，可以系统化回复面试官的（参考：https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md#62-%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-）


================================================================================================
暂时：答案不完整，不满意
【】：可要可不要，避免挖坑
****：答题思路
<>  :

DNS解析过程：
答：DNS的解析过程可以分为递归查询，迭代查询（分级查询）
在浏览器的地址栏上输入url的时候，先进行DNS解析，看一下在我们的主机上有没有对应访问的域名的ip地址，如果有，就直接访问；
如果没有，我们的DNS客户端就会向本地域名服务器发送一个查询请求，如果在本地域名服务器上的高速缓存中找到了ip地址，就直接返回给我们的主机；
如果没有，本地域名服务器就会作为一个DNS客户端向根域名服务器发送查询请求，根域名服务器如果查到，就直接返回ip地址给本地域名服务器；
如果没有，根域名服务器就会告诉本地域名服务器应该到哪一个顶级域名服务器上找，如果查到，就直接返回ip地址给本地域名服务器；
如果没有，顶级域名服务器又会告诉本地域名服务器应该去那个权限域名服务器上找，最后在权限域名服务器上，如果找到就返回ip地址，如果没有就报错

主要原理：
DNS服务器根据域名的层级（主机名.次级域名.顶级域名.根域名），进行分级查询。
需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器，这些服务器知道下一级域名的各种记录。
所谓"分级查询"，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下:
从"根域名服务器"查到"顶级域名服务器"的NS记录和A记录（IP地址）
从"顶级域名服务器"查到"次级域名服务器"的NS记录和A记录（IP地址）
从"次级域名服务器"查出"主机名"的IP地址
仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道"根域名服务器"的IP地址。
回答是"根域名服务器"的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。
 

DNS的常见记录类型有哪一些呢？
答：
（1） A：地址记录（Address），返回域名指向的IP地址。
（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。
（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。
（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。
（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名


1.介绍 js 的基本数据类型。
js的数据基本数据类型有6种：分别是Number,String,Boolean,null,undefined,还有es6中的Symbol。
	==》 类型转换，Symbol
存储位置，存储原因，值拷贝


2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？
js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型（原始值，引用值）

基本数据类型....（参考1）
复杂数据类型指的是 Object 类型，比如说 数组Array、日期对象Date 等。

两种类型间的主要区别在于它们的存储位置不同：
基本数据类型因为占据空间小、大小固定，会被频繁使用，所以存放在栈内存。
复杂数据类型因为占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；
复杂数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得需要的值。

所以：
对于原始值的赋值，实际上，是值拷贝，把一个原始值从栈中取出，然后赋值另外一个变量，两个变量的互相独立的，他们的修改不会互相影响。
对于引用值的赋值，实际上，是地址拷贝，修改其中一个引用值，对于相同地址的引用值也会被修改
	==》浅拷贝 深拷贝（代码）
https://blog.csdn.net/qq_28766729/article/details/83213906


3.什么是堆？什么是栈？它们之间有什么区别和联系？（暂时）
栈和堆的概念存在于数据结构中和操作系统内存中。

在数据结构中，
栈中数据的存取方式为先进后出
堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。【完全二叉树是堆的一种实现方式】。

在操作系统中，内存被分为栈内存和堆内存。

栈内存由编译器自动分配释放，用来保存函数的参数值，局部变量的值等。
堆内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。
	==》数据结构：堆，栈
	==》v8垃圾回收机制
	==》完全二叉树


4.内部属性 [[Class]] 是什么？
一个变量的 typeof值 是"object" 的对象时，内部都包含一个[[class]]的内部属性
这个属性，我们可以把它看作是js里一个内部的分类
这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：

Object.prototype.toString.call( [1,2,3] );
// "[object Array]"

Object.prototype.toString.call( /regex-literal/i );
// "[object RegExp]"
	==》typeof返回值的类型有哪一些？
	==》判断数组和对象的方式有哪些？


5. 介绍 js 有哪些内置对象？
js中的内置对象主要指的是在程序执行前由js在全局作用域里定义的一些全局值属性、函数和用来实例化其他对象的构造函数。
一般我们经常用到的如：
全局变量值 NaN、null、undefined，Infinity
全局函数   parseInt()、parseFloat() 、eval()
用来实例化对象的构造函数 Date、Object、Map、Set、WeakMap、WeakSet、Promise、Proxy等，
数学计算的内置对象如 Math 对象。
	==> eval()
	==> Map, Set,Promise
	==> WeakMap、WeakSet
	==> 异步编程
	==> NaN null的区别？
	==> Proxy、Reflect
	==> JSON 和 JSONP的区别？


6.（暂时）


7. undefined 和 null 的区别？
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义，null 代表的含义是空对象。
一般变量声明了但还没有定义的时候会返回 undefined，
null主要用于赋值给一些可能会返回对象的变量，作为初始化。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，
typeof Null 会返回 “object”，这是一个历史遗留的问题。

当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
	==》为什么void 0 返回一个undefined？（参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void）


8. 如何获取安全的 undefined 值？
因为 undefined 不是js中的保留字，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常使用。

所以我们可以用 void 0 来获得 undefined，因为 void + 表达式 的返回结果是undefined


9. 说几条写 JavaScript 的基本规范？
在平常项目开发中，我们遵守一些这样的基本规范，比如说：

（1）一个函数作用域中所有的变量声明应该尽量提到函数首部；
	用一个 var 声明，不允许出现两个连续的 var 声明；
	声明时如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。

（2）代码中出现地址、时间等字符串时需要使用常量代替。

（3）在进行比较的时候，尽量使用'===', '!=='代替'==', '!='。

（4）不要在内置对象的原型上添加方法，如 Array, Date。

（5）switch 语句必须带有 default 分支。

（6）for 循环必须使用大括号。

（7）if 语句必须使用大括号。


10. JavaScript 原型，原型链？ 有什么特点？
在 js 中，我们可以使用构造函数来创建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个prototype本质是一个对象，它包含了由这个构造函数构造出来的对象共享的方法和属性。 
当我们使用构造函数new一个对象后，这个新建的对象的内部将包含一个指针__proto__，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在的浏览器中都实现了
 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 
Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会通过__proto__属性指向的索引，去它的原型对象里找这个属性，这个原型对象又
会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype, 所以这就
是我们新建的对象为什么能够使用 toString() 等方法的原因。

特点：
JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。所以，当我们修改原型时，与之相关的对象也会继承这一改变。

11. js 获取原型的方法？
obj.__proto__
obj.constructor.prototype    (本质：构造函数.prototype)
Object.getPrototypeOf(obj)


14. typeof NaN 的结果是什么？
typeof NaN的结果是一个字符串number。
NaN 的全称是not a number，NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出
数字类型中的错误情况，即“执行数学运算没有成功的返回的结果”。
NaN 是一个特殊值，它和自身不相等（即 x === x 不成立）的值。而 NaN != NaN为 true。


15. isNaN 和 Number.isNaN 函数的区别？
函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会
返回 true ，会影响 NaN 的判断。（字符串'123'，数值数字123，'NaN'）

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为
准确。
eg:
isNaN('NaN') // true          先转换为数值，在判断是不是为NaN
Number.isNaN('NaN') // false  先判断是不是number类型，在判断是不是为NaN


16. Array 构造函数只有一个参数值时的表现？
Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样
创建出来的数组只是一个空数组，只不过它的 length 属性被设置成了指定的值。
构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。
	==》 数值的方法有哪些？哪些会改变数组，哪些不会改变数组？
	==》 [1,2,,,,3].forEach(ele => console.log(ele)) // 1,2,3


20.{} 和 [] 的 valueOf 和 toString 的结果是什么？
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
备注:
valueOf() 方法返回指定对象的原始值。
toString() 方法返回指定对象的字符串形式。
(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)



26. || 和 && 操作符的返回值？（或运算符，且运算符）
|| 和 && 首先会对我们的操作数 执行 条件判断，如果我们的操作数不是布尔类型的值，就会先进行强制类型转换，转换成一个布尔类型值。
然后再执行条件判断。

对于 || 来说，如果条件判断结果为 true 就返回当前操作数的值，如果为 false 就返回下一个操作数的值。

&& 则相反，如果条件判断结果为 true 就返回下一个操作数的值，如果为 false 就返回当前操作数的值。

|| 和 && 返回它们其中一个操作数的值，而不是返回条件判断的结果


34. javascript 创建对象的几种方式？ 《javascript高级程序设计》
（参考：https://juejin.im/entry/58291447128fe1005cd41c52；http://alvinyuxt.github.io/2016/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/）
我们一般使用对象字面量直接创建一个对象，但是如果要创建大量相似对象的话，这种方式就会产生大量的重复代码。
所以，我们可以使用一些可以实现代码复用的创建对象方式来创建我们的对象，我了解到的方式有这么几种：
	==》 es6 的class类
	==》 new 操作发生了什么？

（1）第一种是工厂模式，工厂模式是通过函数来封装创建对象的细节，从而通过调用函数来达到代码复用的目的。
它的缺点就是创建出来的对象无法和某个类型联系起来，只是简单的封装了复用代码。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。
执行构造函数首先会创建一个对象，然后将对象的原型__proto__指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回this。
因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。
构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。
但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中包含函数的话，那么每次我们都会新建一个函数对象，就会浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个构造函数上都有一个 prototype 属性，这个属性是一个对象，由构造函数创建的所有实例都能共享原型上的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。
这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，
一个是没有办法通过传入参数来初始化值，
另一个是如果存在引用值，那么所有的实例将共享一个对象，一个实例对引用值的改变会影响到所有其他实例。
	==》深度拷贝，浅拷贝

（4）第四种模式是混合模式，组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，
通过构造函数来初始化对象的属性，
通过原型对象来实现函数方法属性的复用。
这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，
这一种模式将原型方法赋值的创建过程 移动到了构造函数的内部，通过判断属性是否存在，
可以实现仅在第一次调用函数时，就对原型对象赋值，以后调用就不需要对原型赋值的效果。这一种方式很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，但它主要是基于一个已有的类型，在实例化时，对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。他除了使用了new操作符并且把使用的包装函数叫做构造函数之外，其他和工厂模式是一样的。它的一个缺点和工厂模式一样，无法实现对象的识别，因为返回的对象与构造函数或者构造函数的原型属性之间没有关系

（7）第七种模式是稳妥构造模式，
稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：
一是新创建的对象的函数属性不使用 this ；
二是不使用 new 操作符调用构造函数
缺点就是和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型

嗯....我目前了解到的就是这么几种方式。



36. 寄生式组合继承的实现？
	代码实现


37.1. 说一下作用域吧？




37.Javascript 的作用域链？
作用域链的本质上是一个指针列表，该指针列表包含了一系列执行期上下文，即作用域Ao。这些变量对象中包含了执行环境中所有变量和函数。
作用域链的前端始终是当前执行上下文对象。
作用域链的末端始终是全局执行上下文对象（也就是全局对象）

作用域链保证对执行环境中有权访问的所有变量和函数的有序访问，
通过作用域链，我们可以访问到外层环境的变量和函数。

当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找，一直找到全局作用域上，如果有就返回，如果没有就返回undefined.



38. 谈谈 This 对象的理解。
this 是执行期上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。
1.第一种是 函数调用模式，当函数不是一个对象的属性时，直接作为函数来调用时，this 指向window。

2.第二种是 方法调用模式，如果函数作为一个对象的方法来调用时，this 指向这个对象。

3.第三种是 构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。

4.第四种是 call、 apply 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。
其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。
call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数必须逐个列举出来。
bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

	==> bind的代码实现


39. eval 是做什么的？
eval的功能是把对应的字符串解析成 JS 代码并运行。
应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。


40.什么是 DOM 和 BOM？
DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。BOM
的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）
对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati
on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对
象的子对象。



43. 三种事件模型是什么？
事件是用户操作页面时，页面发生的交互动作或者页面本身的一些操作，现代浏览器一共有三种事件模型。

第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式可以兼容所有浏览器。
	==》 句柄绑定，本质是赋值操作，再html结构上绑定，或者再dom元素的属性上绑定。

第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个阶段，分别是事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行，默认为false,表示不处于捕获阶段，即默认是冒泡的。

同一个元素绑定在同一个事件上，绑定两个不同的函数，一个是事件冒泡，一个是事件捕获，那么哪一个先执行呢？
答：在触发事件的元素上，按绑定顺序执行，而在该元素的外层元素，执行先执行事件捕获，在执行事件冒泡。
	==》 哪些事件可以事件没有事件冒泡？
		答：focus、blur、change、submit、reset、select
	==》 封装兼容性方法




44. 事件委托是什么？
事件委托本质上是利用了事件冒泡机制。
因为在事件冒泡过程中，子节点触发的事件会冒泡到父节点，父节点可以通过事件源对象获取到目标节点。因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

使用事件代理，我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。



47. javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？
（参考：http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html）
因为我们的现在浏览器是基于es3.0的 和 es5.0的新增方法使用的；
默认情况下，es3.0 和 es5.0产生冲突是由es3.0解决的；
如果启用了es5严格模式：冲突部分就用 es5严格模式解决。
使用"use strict"可以写在js脚本或者局部函数逻辑的最顶端，对应产生的是全局严格模式和局部函数内部严格模式；
"use strict"就是一行字符串，不会对不兼容严格模式的浏览器产生影响；
严格模式的区别有：
不支持with，arguments, callee，func.caller,
变量赋值前必须声明，
局部this必须被赋值(Person.call(null/undefined)赋什么就是什么)，
拒绝重复属性和参数。
	==》callee 和 func.caller的区别？
	==》with的作用？
	==》eval的作用？可以把字符串当作代码来执行，会改变我们的作用域链，规范上不使用
	==》this的指向？



48. 如何判断一个对象是否属于某个类？
第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被修改。
第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString.call() 方法，通过打印对象的[[Class]] 属性来进行判断。
	==》 typeof 的返回值有哪些？
	==》 什么情况下，constructor会被修改？
	==》 实现一个继承的方法
	==》 instanceof实现





50. new 操作符具体干了什么呢？如何实现？
（1）首先创建了一个新的空对象
（2）设置原型，将对象的原型设置为函数的 prototype 对象。
（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
	==》 模拟new 的操作


51.Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？
hasOwnProperty
所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。
这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
	==》 for; for ...in...; for...of...; forEach; in 运算符之间的区别？
	==》 继承的流程图？



52. 对于 JSON 的了解？（参考：https://www.json.org/json-en.html）
JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

JSON 的语法是基于 js 的，但是JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。

另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。




54. js 延迟加载的方式有哪些？
js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。

我了解到的几种方式是：

第一种: 就是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后加载执行。

第二种是:给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步执行，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。【多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。】

第三种是:给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会被阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，如果文档加载完成，再动态的创建 script 标签来引入 js 脚本。
	==》 为什么js的加载，解析，执行会阻塞页面的加载呢？
	==》 说一下时间线？
	==》 async 和 defer的区别？
	==》 怎么动态创建script, 进行一个异步的加载呢？代码实现



70. documen.write 和 innerHTML 的区别？
（参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/write）
document.write() 方法将一个文本字符串写入一个由 document.open() 打开的文档流。
需要注意的是，因为 document.write 需要向文档流中写入内容，所以，若在一个已关闭（例如，已完成加载）的文档上调用 document.write，就会自动调用 document.open，这将清空该文档的内容。
一旦完成了数据写入，建议调用 document.close()，以告诉浏览器当前页面已经加载完毕。写入的数据会被解析到文档结构模型（DOM）里。
在有defer 或 asyn 属性的 script 中，document.write 会被忽略，控制台会显示 "A call to document.write() from an asynchronously-loaded external script was ignored" 的报错信息。
从 Chrome 55 开始，Chrome（可能）不会运行通过 document.write() 注入的<script>，以防止使用 2G 连接的用户找不到 HTTP 缓存。

innerHTML 可以用来获取或者设置某个元素的内容，只会重写页面中的部分内容，内容会被解析到文档中。

所以，这两个的相同点就是，
可以通过字符串来渲染页面的内容，因为写入的数据会被解析到文档里面，同时两个都是会触发重排和重绘的
但是，document.write有可能会清除文档之前的内容；而innerHTML操作的范围比较精确，可以确定要对哪一个元素的内容进行操作，但是，他可能会带来一个跨站攻击的危险。
	==》 跨脚本攻击
	==》 重排和重绘



71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？
（看下成哥的dom的讲解部分）
（1）创建新节点
createDocumentFragment(node);
createElement(node);
createTextNode(text);

（2）添加、移除、替换、插入
appendChild(node)
removeChild(node)
replaceChild(new,old)
insertBefore(new,old)

（3）查找
getElementById();
getElementsByName();
getElementsByTagName();
getElementsByClassName();
querySelector();
querySelectorAll();

（4）属性操作
getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
	==》 querySelector 和 querySelector与其他方法的区别？
	==》 createDocumentFragment有什么优势呢？
             DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。
	



72. innerHTML 与 outerHTML 的区别？
比如说：一个元素div,里面包含三个span的话，
innerHTML属性可以用来获取和设置div的后代元素；只会重写页面中的部分内容，内容会被解析到文档中
而outerHTML属性可以用来获取描述元素div（包括其后代）的序列化HTML片段。




74. JavaScript 类数组对象的定义？
一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组在读写，长度和遍历等方面很类似，但是不能直接调用数组的方法，可以通过改变this指向来使用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有，一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。

类数组转化为数组： slice, solice, concat, Array.form(), ...运算符
var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }
// 1. slice
Array.prototype.slice.call(arrayLike); // ["name", "age", "sex"] 
// 2. splice
Array.prototype.splice.call(arrayLike, 0); // ["name", "age", "sex"] 
// 3. ES6 Array.from
Array.from(arrayLike); // ["name", "age", "sex"] 
// 4. apply
Array.prototype.concat.apply([], arrayLike)

重点说一下类数组arguments：

	==》 类数组的定义
	==》 类数组和数组的对比
	==》 类数组转化为数组
	==》 严格模式下的类数组
	==》 类数组的应用（柯里化，参数不定长....）




76. 数组的 fill 方法？
fill() 方法用一个固定值来填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。



77. [,,,] 的长度？
尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。

JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。

如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。






80. 简单介绍一下 V8 引擎的垃圾回收机制（Garbage Collection）<不熟悉>
v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，
一是新生的对象容易早死，另一个是不死的对象会活得更久。
基于这个假说，v8 引擎将内存分为了新生代和老生代。

新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。
经历过多次垃圾回收的对象被称为老生代。

新生代被分为 From 和 To 两个空间，To 一般是闲置的。
当 From 空间满了的时候会执行 Scavenge （ [ˈskævɪndʒ] ）算法进行垃圾回收。
当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。
这个算法分为三步：

（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。
如果不满足条件则移动 To 空间。

（2）如果对象不存活，则释放对象的空间。

（3）最后将 From 空间和 To 空间角色进行交换。

新生代对象晋升到老生代有两个条件：

（1）第一个是判断是对象否已经经过一次 Scavenge（ [ˈskævɪndʒ] ） 回收。若经历过，则将对象从 From 空间复制到老生代中；
若没有经历，则复制到 To 空间。

（2）第二个是 To 空间的内存使用占比是否超过限制。
当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。
设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。（问：怎么影响的？）

老生代采用了标记清除法和标记整理法。
标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。（问：具体的步骤）
由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记整理法。（问：具体步骤）
	==》 内存碎片

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，
但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 

为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，
每次执行完一小步就让运行逻辑执行一会，就这样交替运行。



83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）
通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。
this === window ? 'browser' : 'node';




91. 介绍一下 js 的节流与防抖？
防抖指的是，在一个事件被触发n秒后，才执行事件回调函数，如果在这n秒内，事件又被重新触发，则会进行一个重新倒计时。
防抖比如可以应用在实时搜索

节流指的是，在我们规定的一段时间内，事件即使被触发多次，事件处理函数只执行一次，
		只有超过这段时间后，去触发事件时，才会执行回调函数。
节流可以应用在比如: 抢购点击上，页面滚动上

【防抖和节流最大的不同是在于，
防抖在每一次事件触发之后，都会去重新计时，在n秒后才会去执行回调函数。
节流是在某段时间内，函数只会执行一次，事件多次被触发，也需要等 超过这段时间后，去触发事件时，才会执行回调函数】
	==》 代码实现


97. 手写 call、apply 及 bind 函数


109.介绍下双向数据绑定的原理

110. Object.defineProperty 介绍？

111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？

131. Set 和 WeakSet 结构？
1. Set是ES6 提供的新的数据结构。它类似于数组，只有属性值，并且成员的值都是唯一的，没有重复的值。Set作为一个构造函数使用，传递的参数必须具备迭代接口，例如：数组,字符串,arguments等。
Set实例对象有add,delete,has,clear等函数.Set可以用来求数组去重操作，数组的交，并，差集等。
2.WeakSet 结构与 Set 类似，weakSet的成员值是唯一的，并且 WeakSet 的成员只能是对象，而不能是其他类型的值。而且WeakSet 中的对象都是弱引用，如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉
	==》 迭代接口是什么？
	==》 怎么添加迭代接口？


132. Map 和 WeakMap 结构？
1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。


136.介绍一下Promise? 
答：
Promise 对象是异步编程的一种解决方案，最早由社区提出。
（Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。）

Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例；这个函数参数是同步执行。

一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。
实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，无法再被改变了。
状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。

Promise的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。
这个回调函数属于微任务，会在本轮事件循环的末尾执行。
then方法会在根据当前的Promise 对象的状态，进行不同的操作：
pending状态时，会将我们的成功回调和失败回调给存储在成功回调的数组和失败回调的数组
resolved状态时，会去触发 then注册的成功的回调函数
rejected状态时，会去触发 then注册的失败的回调函数
最后，then方法会会返回一个新的Promise 对象。
	==> 说一下事件循环？



140. 单例模式模式是什么？
单例模式就是保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现的方法为先判断实例存在与否，如果存在则直接返回，
如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。
适用场景，比如：弹窗，无论点击多少次，弹窗只应该被创建一次。
	=》 封装一个单例模式


145. 观察者模式和发布订阅模式有什么不同？
发布订阅模式其实属于广义上的观察者模式
在观察者模式中，观察者需要直接订阅目标事件。在目标发出 内容改变的事件 后，直接接收事件并作出响应。
而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。
	==》 vue的双向数据绑定

163. EventEmitter 实现




介绍一下js的预编译：
预编译发生在函数执行的前一刻
预编译之前，首先会暗示全局变量，即任何变量，如果未经声明就赋值的话，这个变量就归全局所有；
一切声明的全局变量，都是window上的属性。

预编译的过程，首先会创建执行期上下文AO对象；
然后是变量声明提升，找形参和变量声明，将形参和变量的名作为AO对象的属性名，赋值为undefined;
然后再进行实参和形参的 值 相统一；
然后再当前执行的函数体里找出函数声明，把函数声明的名也作为AO对象的属性名，值为函数体；
预编译完成之后，再执行当前的函数体。这就是预编译的过程。





说一下图片的懒加载和预加载？
答：
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
懒加载：懒加载的主要目的是作为服务器前端的优化，延迟请求或减少请求数。
两种技术的本质：两者的行为是相反的，一个是提前加载，一个是延迟加载甚至不加载。
懒加载可以缓解服务器的压力，预加载则会增加服务器压力。
	==》 怎么样才能减少请求次数？


说一下浅拷贝和深拷贝？
答：
对基本数据类型，浅拷贝是对值的拷贝，没有深拷贝的概念。
对引用类型来说，浅拷贝是对对象地址的拷贝，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，另外一个对象的属性也会改变； 而深拷贝则是开辟新的栈，两个对象间的修改互不影响。
	==》 手写一个深拷贝


手写一个深拷贝？有没有其他的方式？缺点？
1.手写一个
2.对象解构 （层次不能太深）
3.JSON (对于函数，正则表达式等会丢失)
4.$.extend() (需要引入jquery库)






介绍一下Vue单向数据流（说一下你对Vue单向数据流的理解）
答：
数据流，指的是数据流向，即数据的传递。
单向数据流就是说我们的据的传递方向的单一的。

对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性。 
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父组件 prop 的更新会向下流动到子组件中，但是反过来则不行。
这样会防止在子组件中意外改变父组件的状态，从而导致我们的程序的数据流向难以理解。
此外的，每次父组件发生更新时，子组件中所有的 prop 都将会刷新为 最新的值。
这意味着我们不应该在一个子组件内部改变 prop。如果这样操做，Vue 会在浏览器的控制台中发出警告。
 
对于改变 Props 中的值 存在两种情况：  
1.prop作为子组件的数据，并且在子组件中需要修改，在这种情况下，最好 定义一个本地的 data 属性并将这个 prop 用作其初始值。 
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}

2. prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性。
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}

注意, 在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或 对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。

优点： 
1. 所有状态的改变可记录、可跟踪，源头易追溯; 
2. 所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观 更容易理解，有利于应用的可维护性; 
3. 一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data); 
4. 如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。 

缺点： 
1. HTML 代码渲染完成，无法改变，有新数据，就须把旧 HTML 代码去掉， 整合新数据和模板重新渲染; 
2. 代码量上升，数据流转过程变长，出现很多类似的样板代码; 
3. 因为对应用状态独立管理的严格要求(单一的全局 store)，在处理局 部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得 啰嗦及繁琐。 



window的onload事件和domcontentloaded谁先谁后？


XMLHTTPRequest和JSONP的应用场景，以及其分别如何检测请求错误的
答：https://blog.csdn.net/Y_secret/article/details/107184988
1.
XMLHttpRequest用于浏览器端与服务器端异步请求数据从面实现对页面的无刷新修改，支持GET/POST请求，一般用于非跨域的场景。如果需要使用XMLHttpRequest跨域请求数据，需要通过CORS头支持。 
JSONP用于跨域请求数据的场景，只支持GET请求。
2.
XMLHttpRequest异常判断一般通过该对象的readystate和http状态码status来判断，
JSONP的异常判断一般是onerror事件和超时timer来判断。


请列举几个HTML5语义化标签，并说说语义化有什么优点？
答：
<title>：页面主体内容。
<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。
<ul>：无序列表。
<ol>：有序列表。
<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。
<nav>：标记导航，仅对文档中重要的链接群使用。
<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。
<del>：移除的内容。
<ins>：添加的内容。
<code>：标记代码。
<footer>：页脚，只有当父级是body时，才是整个页面的页脚。
<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。
<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。
<em>：将其中的文本表示为强调的内容，表现为斜体。
<mark>：使用黄色突出显示部分文本。
<article>：定义外部的内容，其中的内容独立于文档的其余部分。
<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。
<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。
<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。
<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。
<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。
<blockquoto>：定义块引用，块引用拥有它们自己的空间。
<q>：短的引述（跨浏览器问题，尽量避免使用）。
<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。
<abbr>：简称或缩写。
<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。
<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。
<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）
<progress>：定义运行中的进度（进程）。

优点：
HTML结构清晰
代码可度性好
无障碍阅读
搜索引擎可根据标签的语言确定上下文和权重问题
移动设备能更完美的展示页面
便于团队维护开发


请列举几种除了px外的CSS度量单位并解释其含义。
答：
1. rem 相对于根节点字体大小的单位，比如可以设置 1rem=50px
2. em 相对当前节点于font-size，比如font-size：16px（浏览器默认），则2em=32px
3. vm 即viewpoint width，视窗宽度，比如1vm的宽度为相对于视窗的宽度的百分之一
4. vh 即viewpoint height ，视窗高度，比如1vm的高度为相对于视窗的高度的百分之一


说说你对闭包的理解？
闭包：当内部函数被保存到外部时，将会生成闭包。
使用闭包主要是为了设计私有的方法和变量，避免全局变量的污染，
闭包的缺点就是闭包会常驻内存，导致原有作用域链不释放，造成内存泄漏。
而我们如果遇到闭包的问题，一般通过立即执行函数来解决。

CSS中 link 和@import 的区别是？
(1) link属于HTML标签，而@import是CSS提供的; 
(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; 
(4) link方式的样式的权重 高于@import的权重.

介绍一下box-sizing属性？
box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。
content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分（内容区）的宽/高
border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。
设置width/height属性指的是border + padding + content。
所以，他们最大的区别就是windth/heigth指向不一样，一个是指向内容区，一个是整个盒子的宽高。
标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。

对BFC规范的理解？
BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。
在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。
（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）


说说你对语义化的理解？
1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。


请列举几种除了px外的CSS度量单位并解释其含义。
答：
1. rem 相对于根节点字体大小的单位，比如可以设置 1rem=50px
2. em 相对当前节点于font-size，比如font-size：16px（浏览器默认），则2em=32px
3. vm 即viewpoint width，视窗宽度，比如1vm的宽度为相对于视窗的宽度的百分之一
4. vh 即viewpoint height ，视窗高度，比如1vm的高度为相对于视窗的高度的百分之一



参考：
https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md